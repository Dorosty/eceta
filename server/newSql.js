// Generated by CoffeeScript 1.12.7
(function() {
  var createSqlUtility;

  createSqlUtility = function(client) {
    var finalizeQuery, getReturnObject, normalizePredicate, objectifyArray, select, sendQuery, sql;
    sql = Qdenodify(client, client.query);
    sendQuery = function(query, values) {
      return sql(query, values);
    };
    normalizePredicate = function(predicate) {
      var fields, query, values;
      if (predicate == null) {
        return null;
      }
      if (typeof predicate === 'string') {
        return {
          query: predicate,
          values: []
        };
      }
      if (typeof predicate.query === 'string') {
        if (!((predicate.values != null) && Array.isArray(predicate.values))) {
          predicate.values = [];
        }
        return predicate;
      }
      fields = Object.keys(predicate);
      values = fields.map(function(field) {
        return predicate[field];
      });
      query = fields.map(function(field, i) {
        return "\"" + field + "\" = %";
      }).join(' AND ');
      return {
        query: query,
        values: values
      };
    };
    objectifyArray = function(x) {
      if (Array.isArray(x)) {
        return x.reduce((function(result, y) {
          result[y] = y;
          return result;
        }), {});
      } else {
        return x;
      }
    };
    finalizeQuery = function(query, values) {
      values.forEach(function(_, i) {
        var index, placeholder;
        placeholder = "$" + (i + 1);
        index = query.indexOf('%');
        if (!~query.indexOf(placeholder) && ~index) {
          return query = query.substr(0, index) + placeholder + query.substr(index + 1);
        }
      });
      return query;
    };
    getReturnObject = function(query, values, field) {
      var deferred, finalizedQuery, promise, timeout;
      finalizedQuery = finalizeQuery(query, values);
      deferred = Q.defer();
      timeout = setTimeout(function() {
        return sendQuery(finalizedQuery, values).then((function(arg) {
          var ref, rows;
          rows = arg.rows;
          if (field != null) {
            return deferred.resolve((ref = rows[0]) != null ? ref[field] : void 0);
          } else {
            return deferred.resolve(rows);
          }
        }), deferred.reject);
      });
      promise = deferred.promise;
      promise.unsend = function() {
        clearTimeout(timeout);
        return deferred.resolve(null);
      };
      Object.defineProperty(promise, 'query', {
        get: function() {
          promise.unsend();
          return query;
        }
      });
      Object.defineProperty(promise, 'finalizedQuery', {
        get: function() {
          promise.unsend();
          return finalizedQuery;
        }
      });
      Object.defineProperty(promise, 'values', {
        get: function() {
          promise.unsend();
          return values;
        }
      });
      return promise;
    };
    return {
      insert: function(entity, data, returnId) {
        var fields, query, values;
        if (returnId == null) {
          returnId = false;
        }
        fields = Object.keys(data);
        values = fields.map(function(field) {
          return data[field];
        });
        query = "INSERT INTO \"" + entity + "\" (\"createdAt\", " + (fields.map(function(field) {
          return '"' + field + '"';
        }).join(', ')) + ") VALUES (NOW(), " + ((values.map(function() {
          return '%';
        })).join(', ')) + ")";
        if (returnId) {
          query += " RETURNING \"id\"";
        }
        return getReturnObject(query, values, 'id');
      },
      update: function(entity, data, predicate, returning) {
        var fields, query, r, values;
        predicate = normalizePredicate(predicate);
        returning = objectifyArray(returning);
        fields = Object.keys(data);
        values = (fields.map(function(field) {
          return data[field];
        })).concat(predicate.values);
        query = "UPDATE \"" + entity + "\" SET \"updatedAt\" = NOW(), " + ((fields.map(function(field) {
          return '"' + field + '"' + ' = %';
        })).join(', ')) + " WHERE \"deletedAt\" IS NULL AND " + predicate.query;
        if (returning != null) {
          if (typeof returning === 'string') {
            returning = "\"" + returning + "\"";
          } else {
            r = Object.keys(returning)[0];
            returning = "\"" + returning[r] + "\" AS \"" + r + "\"";
          }
          query += " RETURNING " + returning;
        }
        return getReturnObject(query, values);
      },
      "delete": function(entity, predicate, returning) {
        var query, r;
        predicate = normalizePredicate(predicate);
        returning = objectifyArray(returning);
        query = "UPDATE \"" + entity + "\" SET \"deletedAt\" = NOW() WHERE \"deletedAt\" IS NULL AND " + predicate.query;
        query = "DELETE FROM \"" + entity + "\" WHERE " + predicate.query;
        if (returning != null) {
          if (typeof returning === 'string') {
            returning = "\"" + returning + "\"";
          } else {
            r = Object.keys(returning)[0];
            returning = "\"" + returning[r] + "\" AS \"" + r + "\"";
          }
          query += " RETURNING " + returning;
        }
        return getReturnObject(query, predicate.values);
      },
      select: select = function(entities, fieldss, predicate) {
        var allFields, query, values;
        predicate = normalizePredicate(predicate);
        if (!Array.isArray(entities)) {
          entities = [entities];
          fieldss = [fieldss];
        }
        allFields = entities.map(function(_, i) {
          var fields;
          fields = fieldss[i];
          if (fields == null) {
            return null;
          }
          fields = objectifyArray(fields);
          if (typeof fields === 'string') {
            if (fields !== '*') {
              fields = "x" + i + ".\"" + fields + "\" AS \"" + fields + "\"";
            } else {
              fields = "x" + i + ".*";
            }
          } else {
            fields = Object.keys(fields).map(function(field) {
              return "x" + i + ".\"" + fields[field] + "\" AS \"" + field + "\"";
            }).join(', ');
          }
          return fields;
        }).filter(function(fields) {
          return fields != null;
        }).join(', ');
        query = "SELECT " + allFields + " FROM " + ((entities.map(function(entity, i) {
          return '"' + entity + '" x' + i;
        })).join(', '));
        query += ' WHERE \"deletedAt\" IS NULL';
        if (predicate != null) {
          query += " AND " + predicate.query;
          values = predicate.values;
        } else {
          values = [];
        }
        return getReturnObject(query, values);
      },
      count: function(entity, predicate) {
        var query, values;
        predicate = normalizePredicate(predicate);
        values = predicate.values;
        query = "SELECT COUNT(*) AS cnt FROM \"" + entity + "\" WHERE \"deletedAt\" IS NULL AND " + predicate.query;
        return getReturnObject(query, values, 'cnt');
      },
      exists: function(entities, predicate) {
        var query, ref, values;
        if (!Array.isArray(entities)) {
          entities = [entities];
        }
        ref = select(entities, entities.map(function() {
          return '*';
        }), predicate), query = ref.query, values = ref.values;
        query = "SELECT EXISTS(" + query + ") AS ex";
        return getReturnObject(query, values, 'ex');
      },
      query: function(query, values) {
        if (!Array.isArray(values)) {
          values = [];
        }
        return sendQuery(query, values);
      }
    };
  };

}).call(this);
